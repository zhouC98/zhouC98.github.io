<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>成为一个有目标的学习者</title>
    <link href="/2020/12/06/learner/"/>
    <url>/2020/12/06/learner/</url>
    
    <content type="html"><![CDATA[<p>我一个好朋友，他在一家国内较大借贷平台做前端工程师，每天五点起床，早早的到公司，开始读一些经典的前端类的书籍。起的这么早的动力是觉得自己还没能够掌握前端的很多细节，真正在做开发的时候，依然会忘记之前看到过的东西，总是下意识的告诉自己：『可能我还处在入门水平』。<br>长此以往，起的越来越早，中午同事休息联机玩儿手游的时候，也不放过时间去看书，压力也随之变大。开始否认自己在转行前端之前的时光，感觉都被浪费掉了似的，越是如此，越是无法挣脱，逐步的走到死胡同中，彷徨，痛苦。<br>他很痛苦，希望我能提些自己的看法。<br>我想，很多人都曾有过这种时光。就好比高考前的各种模拟试题一样，总有一种人，喜欢在做模拟试题前，把整本书都先过一遍。这样真的有意义吗？我认为回报是很小的。因为你定了一个有些迂回和逃避性质的目标。当入门阶段已经走过以后，你没有必要再从头开始，这是一个会浪费时间、消耗体力的目标，只会让你丧失学习的动力，因为你不再会有比第一次学会更强的正向反馈了，当你耗费大量时间和体力过了一遍以后，依然无所得，这是多么令人挫败的一个过程啊。<br>那问题来了，一旦入门后，如何得到一个更有激励性质的正反馈呢？<br>依然是定一个目标，定一个你从未尝试或达到过的目标，让新的目标去刺激你的多巴胺和肾上腺素，让你对某一个东西、技术产生持续的亢奋，从而无形中成为终生学习者。<br>对于技术人来说，新的目标可以是做一个解决自己生活中遇到问题的小产品，努力做到 1000 日活，做一个开源项目，努力得到 1000 个 Star，做一个小工具，努力赚到 1000 人民币，做一个小社群，努力拥有 1000 个注册用户，或者开一篇博客，写一个公众号，努力做到 1000 阅读。<br>这些都是可以成为刺激你的下一个源泉。很多很能折腾的人，总是在持续不断的折腾，就是因为他们总是在不断的接收正反馈，他们在不断的认可自己的过程中。<br>不要因为别人说一本书好，或是一篇文章，一类技术好，就去学它，其实根本没有必要，因为你学它的动力其实是伪动力，学有所用才是可能持续学习的动力，主观的坚持不是可持续的真正动力。<br>我其实一直是很不主张去读其他人的技术文章，至少大多数技术文章都是对你无益的，读的越多，你越是会产生彷徨和焦虑，感觉自己没有成长，缺少自信。缺少自信的表现是你会恐惧未来遇到的新问题，你还是得大量依赖搜索引擎去读几百篇博客去解决一个问题，你没有自己真正的独立思考，你只解决了一个眼前问题，你没有办法套用到千千万万个问题上，你无法亢奋自己的神经，而产生持续的学习和研究欲望。<br>大量读别人的文章，其实你也无法得到一个独立解决问题的方法论，你会滋生思想的懒惰，很多美好的事物和机会，也会和你擦身而过。<br>有的时候，读其他人的技术文章也会让自己产生一种诡异的满足感，你会感到我貌似很多东西都会，只是有些不熟罢了，真的如此吗？<br>举个自己的例子，我当初在准备炒股票前，在雪球上读了很多文章，还专门把牛人们分成了一组，感觉自己差不多了，随即开户砸钱进去，但直到真正开始操盘的时候，这种我已经学会了的错觉，让我赔了不少。有时候就跟你看了一百篇某个技术点的技术文章，真的开始写的时候，什么也想不起来，又得打开一篇，照猫画虎做完，却发现崩溃了。WTF。其实你并没有学会。<br>我主张你去看原始的资料，主张你去读系统的书籍，主张你去研究官方或是优秀项目的源码。这些都是一手资料和优质 Demo。这才是真正的方法论，Google 是不会给你带来安全感的。<br>而且很多复杂的东西，其实很难用一篇博客文章写清楚。越是清楚其中逻辑和原理的人，反而越是很少写技术文章，一来因为这些技术人感觉还有很多东西要研究，复杂问题写起来总是长篇大论，依赖知识也非常多，写起来麻烦。二来，研究到这些复杂东西的人，往往已经掌握了方法论，也不需要读这些文章，非要写一篇文章的话，只用只言片语提及思路，便够了。<br>如果你在入门阶段，你读什么都可以，如果你想要有些突破，就按上面三条方法来吧，一定让你有所收获，如果你想有更大的突破，那就先给自己定个从未达到过的目标。<br>最后，花些时间娱乐，不要总是那么紧张，生活也是很大的一门学问。</p><blockquote><p>正如 文明VI 中提到的一句名言：<br>那些没时间娱乐的人，他们的时间会花在生病上。——约翰 沃纳梅克</p></blockquote><p><a href="https://daimajia.com/2017/02/25/you-need-a-goal">原文出处</a></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>饥荒攻略</title>
    <link href="/2020/12/04/Starve/"/>
    <url>/2020/12/04/Starve/</url>
    
    <content type="html"><![CDATA[<p>1、按住shift并按左键可把箱子里的物品拿到物品栏或把物品栏的物品拿到箱子里<br>2、回旋镖在发出去重新回来时可按空格接住<br>3、扔胡萝卜在地上引诱小兔子并击杀<br>4、扔浆果在地上引诱火鸡并击杀<br>5、按住ctrl键并对怪物按左键强制攻击<br>6、按ctrl并对物品栏的物品左键即可把物品分堆<br>7、对物品左键后按住ctrl键即可把物品一个一个扔在地上，对火药特别有用<br>9、不建议在前期移植草和浆果，因为前期没有足够肥料<br>11、饥饿腰带起到减慢饥饿速度的作用，是大力士的神器<br>12、寒冰护符可以使攻击你的怪物逐渐冰冻<br>13、当啜食者在你头上时，会提供光明，但会快速流失饥饿值<br>14、跳进虫洞降15脑残<br>15、火腿棒，木甲，猪皮帽在前期为你提供基本的攻击能力和不死之身，前期快速造出它们<br>16、草原有牛毛，有兔子，有草，造家首选<br>17、墙壁只是为了分离界限拖延时间，前期不必浪费资源建造<br>18、疯的猪掉的东西更多<br>19、4快怪物肉喂疯一头猪<br>20、下洞穴准备物品，矿工帽，一组牛肉干，长矛，木甲，打包帐篷<br>21、不要手贱把活木树烧掉，连渣都不剩<br>22、抓住蝴蝶后在地上右键种花<br>23、将抓来的蜜蜂丢在地上它会自动为你种花。<br>24、在洞穴时随时注意精神值的下降<br>25、怪物的保险打法：<br>蜘蛛：一个直接打，一群一躲一下<br>高鸟：一躲一下<br>牛：打一下，与其他牛拉开距离直至其他牛走开，然后一躲四下<br>树精：一躲三下<br>猪：一躲三下(一群直接跑)<br>疯猪：一躲两下<br>杀人蜂：带蜂帽打死<br>兔人：一躲两下(一群直接跑)<br>蠕虫：一躲4下、一躲两下，循环往复。(一群找东西拉仇恨)<br>狗(所有种类)：高攻的武器躲一下直接打死，长矛一躲两下(一群找东西拉仇恨)<br>梦魇(所有种类)：一躲一下<br>触手：不建议直接打，可以让触手帮忙打鱼人、蜘蛛、巨鹿什么的。<br>鱼人：同兔人<br>巨鹿：难走位，建议一、两套护甲(一套包括头部及身体)硬撸，拉它去打蜘蛛、树人、触手什么的也行。<br>远古犀牛：两三套护甲硬撸<br>机械马：乘它攻击完立即回头攻击两下。<br>机械主教：木甲站撸<br>机械犀牛：反正它难撞到你，别理他，适当地躲一下<br>女皇：一躲四下，产蜘蛛时拉开距离灭掉蜘蛛。<br>石虾：不建议攻击<br>注：“躲”为其攻击后立即回头，如有迟疑，等待下一时机<br>26、控制台的英文可用ctrl+l去除<br>27、进游戏后按start弹回主界面的细看置顶帖<br>28、镐头用到3%时留下来做暖石<br>30、洞穴不能提早打开<br>31、在饥荒制造栏中有很多东西是无用的，如指南针，雨量计等，不必造<br>32、荧光果喂疯猪是最好的刷肥料方式<br>33、步行手杖可打怪，可探图，可走位，无限耐久，前期捡到它，你运气真的<br>34、alt键检查食物和装备<br>35、如果刷出有杀伤力的奇遇，可以在旁边放蜘蛛巢，你将会收获无限腺体和蜘蛛网，3组左右的腐烂食物，最好最后收获，否则小心点捡。<br>36、石虾的繁殖能力强，带到地上要么守家，要么破坏生态平衡<br>37、有时候破坏性开发也是需要的，如烧树，挖兔子洞等。<br>38、用食人花可以秒杀小型生物<br>39、在烹煮锅里做好的食物，不拿出来则永远不坏哦!<br>40、用高脚鸟蛋晚上放在火边，白天远离火，可敷出小高脚鸟<br>41、晒肉架最好在你有肉，或需要时再拿下来，不同时间的肉分时间放，先吃快坏的，如果黄了，把最新鲜的叠加一起变成绿的再吃，食物充裕时把生肉放红再挂上，换你一个新鲜的，很不错哦。<br>42、老太太的书可以最大化利用<br>43、猴子会偷窃你的物品，并放进自己的腰包，不过别担心，它还会用便便(△(攻击你，收获便便<br>44、有些动物会佩戴帽子，如猴子、猪人、兔人<br>45、按ctrl+f键可以自动攻击离玩家最近的生物<br>46、用肉只能跟猪王换一块金子，而用从坟墓里挖出来的小玩意可以换六块金子<br>47、有金色条纹的石头百分之百能挖出金块<br>48、试金石旁的猪头桩可以用锤子拆掉<br>49、青蛙可以用陷阱捕捉<br>50、吃浆果饥饿值回得较多，建议烤熟了吃<br>触手走位稳可以打一走一。蝴蝶有2％或者。。。反正低概率出黄油，建议直接吃，回40或者50血，非，不怎么爆，但知道有。</p>]]></content>
    
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debounce, throttle原理及实现</title>
    <link href="/2020/12/04/debouce/"/>
    <url>/2020/12/04/debouce/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param </span>fn &#123;Function&#125;   实际要执行的函数</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param </span>delay &#123;Number&#125;  延迟时间，也就是阈值，单位是毫秒（ms）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span>     </span>返回一个“去弹跳”了的函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> timer<br>  <span class="hljs-comment">// 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 保存函数调用时的上下文和参数，传递给 fn</span><br>    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span><br>    <span class="hljs-comment">// 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn    clearTimeout(timer)</span><br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <span class="hljs-comment">// 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），</span><br>    <span class="hljs-comment">// 再过 delay 毫秒就执行 fn</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(context, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>debounce 返回了一个闭包，这个闭包依然会被连续频繁地调用，但是在闭包内部，却限制了原始函数 fn 的执行，强制 fn 只在连续操作停止后只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流throttle代码（定时器）：</span><br><span class="hljs-keyword">var</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, delay</span>) </span>&#123;            <br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;            <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;               <br>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;                <br>        <span class="hljs-keyword">if</span> (!timer) &#123;                    <br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                        <br>                func.apply(context, args);                        <br>                timer = <span class="hljs-literal">null</span>;                    <br>            &#125;, delay);                <br>        &#125;            <br>    &#125;        <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>animation和transition的区别</title>
    <link href="/2020/12/03/animation/"/>
    <url>/2020/12/03/animation/</url>
    
    <content type="html"><![CDATA[<p>animation 可以用 name 设置动画的名称，用 duration 设置动画完成的周期，用 timing-function 设置动画的速度曲线，delay 设置动画什么时候开始，iteration-count 设置动画播放的次数，direction 规定下一个周期是否逆向的播放，play-state 动画是否正在进行或者暂停，fill-mode 设置动画停了之后位置什么状态<br>　　transition 用 property 去设置过渡效果的属性名称，duration 设置过渡效果的周期，timing-function 规定速度效果的速度曲线，delay 设定过渡效果什么时候开始；<br>　　<br>　　区别：<br>　　　　1、transition 是过渡，是样式值的变化的过程，只有开始和结束；animation 其实也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态；<br>　　　　2、animation 配合 @keyframe 可以不触发时间就触发这个过程，而 transition 需要通过 hover 或者 js 事件来配合触发；<br>　　　　3、animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次；<br>　　　　4、animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧；<br>　　　　5、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了；</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
