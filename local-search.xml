<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>饥荒攻略</title>
    <link href="/2020/12/04/Starve/"/>
    <url>/2020/12/04/Starve/</url>
    
    <content type="html"><![CDATA[<p>1、按住shift并按左键可把箱子里的物品拿到物品栏或把物品栏的物品拿到箱子里<br>2、回旋镖在发出去重新回来时可按空格接住<br>3、扔胡萝卜在地上引诱小兔子并击杀<br>4、扔浆果在地上引诱火鸡并击杀<br>5、按住ctrl键并对怪物按左键强制攻击<br>6、按ctrl并对物品栏的物品左键即可把物品分堆<br>7、对物品左键后按住ctrl键即可把物品一个一个扔在地上，对火药特别有用<br>9、不建议在前期移植草和浆果，因为前期没有足够肥料<br>11、饥饿腰带起到减慢饥饿速度的作用，是大力士的神器<br>12、寒冰护符可以使攻击你的怪物逐渐冰冻<br>13、当啜食者在你头上时，会提供光明，但会快速流失饥饿值<br>14、跳进虫洞降15脑残<br>15、火腿棒，木甲，猪皮帽在前期为你提供基本的攻击能力和不死之身，前期快速造出它们<br>16、草原有牛毛，有兔子，有草，造家首选<br>17、墙壁只是为了分离界限拖延时间，前期不必浪费资源建造<br>18、疯的猪掉的东西更多<br>19、4快怪物肉喂疯一头猪<br>20、下洞穴准备物品，矿工帽，一组牛肉干，长矛，木甲，打包帐篷<br>21、不要手贱把活木树烧掉，连渣都不剩<br>22、抓住蝴蝶后在地上右键种花<br>23、将抓来的蜜蜂丢在地上它会自动为你种花。<br>24、在洞穴时随时注意精神值的下降<br>25、怪物的保险打法：<br>蜘蛛：一个直接打，一群一躲一下<br>高鸟：一躲一下<br>牛：打一下，与其他牛拉开距离直至其他牛走开，然后一躲四下<br>树精：一躲三下<br>猪：一躲三下(一群直接跑)<br>疯猪：一躲两下<br>杀人蜂：带蜂帽打死<br>兔人：一躲两下(一群直接跑)<br>蠕虫：一躲4下、一躲两下，循环往复。(一群找东西拉仇恨)<br>狗(所有种类)：高攻的武器躲一下直接打死，长矛一躲两下(一群找东西拉仇恨)<br>梦魇(所有种类)：一躲一下<br>触手：不建议直接打，可以让触手帮忙打鱼人、蜘蛛、巨鹿什么的。<br>鱼人：同兔人<br>巨鹿：难走位，建议一、两套护甲(一套包括头部及身体)硬撸，拉它去打蜘蛛、树人、触手什么的也行。<br>远古犀牛：两三套护甲硬撸<br>机械马：乘它攻击完立即回头攻击两下。<br>机械主教：木甲站撸<br>机械犀牛：反正它难撞到你，别理他，适当地躲一下<br>女皇：一躲四下，产蜘蛛时拉开距离灭掉蜘蛛。<br>石虾：不建议攻击<br>注：“躲”为其攻击后立即回头，如有迟疑，等待下一时机<br>26、控制台的英文可用ctrl+l去除<br>27、进游戏后按start弹回主界面的细看置顶帖<br>28、镐头用到3%时留下来做暖石<br>30、洞穴不能提早打开<br>31、在饥荒制造栏中有很多东西是无用的，如指南针，雨量计等，不必造<br>32、荧光果喂疯猪是最好的刷肥料方式<br>33、步行手杖可打怪，可探图，可走位，无限耐久，前期捡到它，你运气真的<br>34、alt键检查食物和装备<br>35、如果刷出有杀伤力的奇遇，可以在旁边放蜘蛛巢，你将会收获无限腺体和蜘蛛网，3组左右的腐烂食物，最好最后收获，否则小心点捡。<br>36、石虾的繁殖能力强，带到地上要么守家，要么破坏生态平衡<br>37、有时候破坏性开发也是需要的，如烧树，挖兔子洞等。<br>38、用食人花可以秒杀小型生物<br>39、在烹煮锅里做好的食物，不拿出来则永远不坏哦!<br>40、用高脚鸟蛋晚上放在火边，白天远离火，可敷出小高脚鸟<br>41、晒肉架最好在你有肉，或需要时再拿下来，不同时间的肉分时间放，先吃快坏的，如果黄了，把最新鲜的叠加一起变成绿的再吃，食物充裕时把生肉放红再挂上，换你一个新鲜的，很不错哦。<br>42、老太太的书可以最大化利用<br>43、猴子会偷窃你的物品，并放进自己的腰包，不过别担心，它还会用便便(△(攻击你，收获便便<br>44、有些动物会佩戴帽子，如猴子、猪人、兔人<br>45、按ctrl+f键可以自动攻击离玩家最近的生物<br>46、用肉只能跟猪王换一块金子，而用从坟墓里挖出来的小玩意可以换六块金子<br>47、有金色条纹的石头百分之百能挖出金块<br>48、试金石旁的猪头桩可以用锤子拆掉<br>49、青蛙可以用陷阱捕捉<br>50、吃浆果饥饿值回得较多，建议烤熟了吃<br>触手走位稳可以打一走一。蝴蝶有2％或者。。。反正低概率出黄油，建议直接吃，回40或者50血，非，不怎么爆，但知道有。</p>]]></content>
    
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debounce, throttle原理及实现</title>
    <link href="/2020/12/04/debouce/"/>
    <url>/2020/12/04/debouce/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param </span>fn &#123;Function&#125;   实际要执行的函数</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param </span>delay &#123;Number&#125;  延迟时间，也就是阈值，单位是毫秒（ms）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span>     </span>返回一个“去弹跳”了的函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> timer<br>  <span class="hljs-comment">// 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 保存函数调用时的上下文和参数，传递给 fn</span><br>    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span><br>    <span class="hljs-comment">// 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn    clearTimeout(timer)</span><br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <span class="hljs-comment">// 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），</span><br>    <span class="hljs-comment">// 再过 delay 毫秒就执行 fn</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(context, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>debounce 返回了一个闭包，这个闭包依然会被连续频繁地调用，但是在闭包内部，却限制了原始函数 fn 的执行，强制 fn 只在连续操作停止后只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流throttle代码（定时器）：</span><br><span class="hljs-keyword">var</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, delay</span>) </span>&#123;            <br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;            <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;               <br>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;                <br>        <span class="hljs-keyword">if</span> (!timer) &#123;                    <br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                        <br>                func.apply(context, args);                        <br>                timer = <span class="hljs-literal">null</span>;                    <br>            &#125;, delay);                <br>        &#125;            <br>    &#125;        <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>animation和transition的区别</title>
    <link href="/2020/12/03/animation/"/>
    <url>/2020/12/03/animation/</url>
    
    <content type="html"><![CDATA[<p>animation 可以用 name 设置动画的名称，用 duration 设置动画完成的周期，用 timing-function 设置动画的速度曲线，delay 设置动画什么时候开始，iteration-count 设置动画播放的次数，direction 规定下一个周期是否逆向的播放，play-state 动画是否正在进行或者暂停，fill-mode 设置动画停了之后位置什么状态<br>　　transition 用 property 去设置过渡效果的属性名称，duration 设置过渡效果的周期，timing-function 规定速度效果的速度曲线，delay 设定过渡效果什么时候开始；<br>　　<br>　　区别：<br>　　　　1、transition 是过渡，是样式值的变化的过程，只有开始和结束；animation 其实也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态；<br>　　　　2、animation 配合 @keyframe 可以不触发时间就触发这个过程，而 transition 需要通过 hover 或者 js 事件来配合触发；<br>　　　　3、animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次；<br>　　　　4、animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧；<br>　　　　5、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了；</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
